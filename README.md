AESA Radar Simulation (1-D) — Project Description

This project implements a complete one-dimensional Active Electronically Scanned Array (AESA) radar model using object-oriented C++. The goal is to simulate the underlying electromagnetic behavior and antenna-array physics through well-organized classes that each represent a distinct mathematical concept. The simulation includes RF system modeling, wavelength and wavenumber computation, phase calculation for a uniform linear array, array factor evaluation, null detection, beamwidth estimation, grating-lobe prediction, array gain computation, radar range equation modeling, Doppler frequency and phase evolution, and angle-of-arrival estimation based on phase differences. All these calculations are integrated in the main program to demonstrate how the radar’s physical parameters flow into one another.

The RF_Settings class computes the radar’s wavelength and wavenumber from its operating frequency and wave-propagation velocity. Calculation_Settings computes the phase parameter used in array theory, defined as k·d·(sin(steer) − sin(observation)). Array_Settings evaluates the array factor magnitude, which describes how the antenna elements interfere constructively or destructively. Null_Direction_Testing determines whether a given phase term produces a null in the radiation pattern. Main_lobe_angle_rad_Settings stores the array’s steering direction. Beamwidth_Settings computes the first-null beamwidth and half-power beamwidth using standard approximations. Grating_lobe_condition_Settings evaluates where grating lobes appear and checks whether the spacing rule d ≤ λ/2 is satisfied. Several additional classes inside the aesa_1d namespace provide signal-processing capabilities: Array_Gain_Settings computes linear and decibel gain; Radar_Range_Equation_Settings implements the monostatic radar range equation; Doppler_Settings computes Doppler frequency and Doppler phase over time; and Angle_Estimation_Settings estimates arrival angle from phase differences and computes angular resolution limits.

The main program ties all components together. It begins by constructing RF settings to obtain wavelength and wavenumber, then applies these values to compute phase terms, array factor behavior, and radiation-pattern characteristics. It evaluates beamwidth, checks for grating lobes, computes array gain, applies the radar range equation to determine received signal strength, models Doppler shift due to relative motion, and finally estimates arrival angle based on phase measurement. Each step prints numerical results so the radar’s behavior can be observed directly. The complete system reflects the workflow of a real AESA radar at a conceptual level.

The program can be compiled using a modern C++ compiler such as g++ with the command g++ -std=c++20 -O2 main_aesa.cpp -o aesa_sim, and then executed via ./aesa_sim. The design is intentionally modular so additional subsystems can be added without restructuring the code. This foundation supports future expansion into two-dimensional arrays, digital beamforming using FFTs, range-Doppler processing chains, CFAR detection, and high-accuracy angle estimation methods such as MUSIC or ESPRIT. The project aligns with aerospace-engineering software practices by isolating each physical concept into a dedicated class and ensuring that no global state is used.

